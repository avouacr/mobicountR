

# Quadtree on FV 2019 indoor grid -----------------------------------------
# Test on MEUSE departement


install.packages("~/mobicount-project/minior-master.tar.gz", repos = NULL)
install.packages(c("fst", "RcppArmadillo"))

library(tidyverse)
library(data.table)
library(minior)
library(fst)
library(Rcpp)
library(RcppArmadillo)
library(sf)

set_minio_shared()





# Preprocess FV grid ------------------------------------------------------

# Import FV grid

get_file_local("MobiCount/fv/csg_02_19/grid_fv_02_19.fst",
               "etgtk6",
               ext_dir = "~/fv")

grid_fv <- read_fst("~/fv/grid_fv_02_19.fst", as.data.table = TRUE)

# Subset FV grid to the bounding box of a chosen department

dpt <- 51

get_file_local("MobiCount/shp/departements-20180101-shp.zip",
               "etgtk6",
               ext_dir = "~/shp", uncompress = T)

dep_sub <- st_read("~/shp/dep_francemetro_2018.shp",
                   stringsAsFactors = F, crs = 2154) %>%
  st_transform(27572) %>%
  filter(code == as.character(dpt))

dep_bbox <- st_bbox(dep_sub)

# First rough filtering by bounding box
grid_sub <- grid_fv[x >= dep_bbox$xmin & x <= dep_bbox$xmax &
                    y >= dep_bbox$ymin & y <= dep_bbox$ymax]

# Second filtering by intersection with actual department limit
ind_inter_dep <- grid_sub %>%
  st_as_sf(coords = c("x", "y"), crs = 27572) %>%
  st_intersects(dep_sub) %>%
  map_lgl(function(x) {
    if (length(x) == 0) return(FALSE)
    else return(TRUE)
  })

grid_sub <- grid_sub[ind_inter_dep, ]

# Build grid from centroids

r <- 100
grid_sub$geometry <- sprintf("POLYGON ((%f %f, %f %f, %f %f, %f %f, %f %f))",
                             grid_sub$x-r, grid_sub$y+r, grid_sub$x+r, grid_sub$y+r,
                             grid_sub$x+r, grid_sub$y-r, grid_sub$x-r, grid_sub$y-r,
                             grid_sub$x-r, grid_sub$y+r)
# 
# grid_sub_full <- st_as_sf(grid_sub, wkt = "geometry", crs = 27572)
# 
# # Assign building volume to grid ------------------------------------------
# 
# # Import BD Topo shapefile of choosen department
# 
# get_file_local(str_c("MobiCount/shp/bdtopo_2019/batiindi_dep_", dpt, ".zip"),
#                "etgtk6", ext_dir = "~/shp", uncompress = T)
# 
# bdtopo_dep <- st_read(str_c("~/shp/batiindi_dep_", dpt, ".shp"), crs = 2154) %>%
#   select(ID, HAUTEUR, geometry) %>%
#   st_transform(27572)
# 
# build_vol_grid <- bdtopo_dep %>%
#   st_intersection(grid_sub_full) %>%
#   mutate(area_inter = st_area(.),
#          volume = area_inter*HAUTEUR) %>%
#   st_set_geometry(NULL) %>%
#   group_by(x, y) %>%
#   summarise(build_vol = round(sum(volume))) %>%
#   right_join(grid_sub) %>%
#   select(-geometry) %>%
#   mutate(build_vol = replace_na(build_vol, 0))
# 
# put_df(build_vol_grid,
#        filename = "build_vol_fv_grid.csv",
#        dir_minio = str_c("MobiCount/fv/csg_02_19/quadtree_dpt_", dpt),
#        bucket = "etgtk6")

path_fv_build <- str_c("MobiCount/fv/csg_02_19/quadtree_dpt_", dpt, "/",
                       "build_vol_fv_grid.csv")

build_vol_grid <- read_csv(get_file(
  path_fv_build, 
  "etgtk6")) %>%
  mutate(grid_100_id = str_c(x/100, y/100, sep = "_"))

# # Export initial grid to visualize in QGIS
# 
# build_vol_grid %>%
#   full_join(grid_sub) %>%
#   select(build_vol, geometry) %>%
#   st_as_sf(wkt = "geometry", crs = 27572) %>%
#   st_write(str_c("~/fv_grid_build_vol_100m_", dpt, ".shp"))

# K-means of building volume for class choice
sort(kmeans(build_vol_grid$build_vol, centers = 5)$centers)


# Quadtree ----------------------------------------------------------------

# Format grid as a squared matrix (which size is a power of 2)
size_init <- 100
build_vol_grid$i <- (build_vol_grid$x - min(build_vol_grid$x)) / size_init + 1 
build_vol_grid$j <- (build_vol_grid$y - min(build_vol_grid$y)) / size_init + 1 
max_i_j <- max(max(build_vol_grid$i), max(build_vol_grid$j))
shape <- 2^(ceiling(log2(max_i_j)))

mat_init <- matrix(0, shape, shape, 
                         dimnames = list(1:shape, 1:shape)) 
mat_init[cbind(build_vol_grid$i, build_vol_grid$j)] <- build_vol_grid$build_vol

n_rows <- n_cols <- nrow(mat_init)

# Quatree

# Shutoff parameter of quadtree : minimum building volume per tile
# min_volume <- 0
sourceCpp("R codes/2019/FV_cov_maps/quadtree/quadtree.cpp")

# Retrieve quadtree results

add_i <- add_cpp[[1]]
add_j <- add_cpp[[2]]

flat_mat <- tibble(add_i = as.vector(add_i),
                  add_j = as.vector(add_j),
                  vol = as.vector(mat_init),
                  i = as.numeric(rep(row.names(mat_init), ncol(mat_init))),
                  j = as.numeric(rep(colnames(mat_init),each = nrow(mat_init))),
                  x = (i-1) * size_init + min(build_vol_grid$x),
                  y = (j-1) * size_init + min(build_vol_grid$y))

setDT(flat_mat)

# Compute output tiles centroid and size, complete grid
# and filter data to the department boundaries

grid_quadtree <- flat_mat[, .(x_quad = (max(x) + min(x)) / 2,
                              y_quad = (max(y) + min(y)) / 2,
                              size = sqrt(.N) * size_init), 
                          by = .(add_i, add_j)] %>%
  mutate(geometry = sprintf("POLYGON ((%f %f, %f %f, %f %f, %f %f, %f %f))",
                            x_quad - size/2, y_quad + size/2, x_quad + size/2, y_quad + size/2,
                            x_quad + size/2, y_quad - size/2, x_quad - size/2, y_quad - size/2,
                            x_quad - size/2, y_quad + size/2)) %>%
  st_as_sf(wkt = "geometry", crs = 27572) %>%
  st_intersection(dep_sub) %>%
  select(add_i, add_j, x_quad, y_quad)

# # Export for analysis in QGIS
# st_write(grid_quadtree, str_c("~/quadtree_grid_", dpt, ".shp"))






# Assign probabilities to aggregated grid ---------------------------------

# Create correspondance table between initial and aggregated grids

corresp_grids <- grid_quadtree %>%
  st_set_geometry(NULL) %>%
  left_join(flat_mat) %>%
  as_tibble() %>%
  select(x_quad, y_quad, x, y)

setDT(corresp_grids)

corresp_grids %>% select(x,y) %>% unique() %>% nrow()

# Merge with DMA tables to get probabilities per tile

get_file_local("MobiCount/fv/csg_02_19/indoor_02_19.fst",
               "etgtk6",
               ext_dir = "~/fv")

indoor <- read_fst("~/fv/indoor_02_19.fst", as.data.table = TRUE)
indoor_dma_table <- indoor %>% rename(x = x_tile, y = y_tile)

indoor_dma_quad <- merge(corresp_grids, indoor_dma_table)

# Normalize probabilities so that they sum to one for each quadtree tile
# over all antennae

agg_probas <- indoor_dma_quad[, .(proba = sum(proba)), 
                   by = .(x_quad, y_quad, dma_name)] %>%
  group_by(x_quad, y_quad) %>%
  mutate(proba = proba / sum(proba))

put_df(agg_probas,
       filename = "indoor_quad_probas.csv",
       dir_minio = str_c("MobiCount/fv/csg_02_19/quadtree_dpt_", dpt),
       bucket = "etgtk6")



